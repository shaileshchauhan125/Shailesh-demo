<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Game</title>
    <style>
        :root {
            --board-size: 90vmin;
            --cell-size: calc(var(--board-size) / 15);
            --token-size: calc(var(--cell-size) * 0.7);
            --red: #ff4d4d;
            --green: #4caf50;
            --yellow: #ffeb3b;
            --blue: #2196f3;
            --light-gray: #f0f0f0;
            --dark-gray: #333;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--dark-gray);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            flex-direction: column;
            gap: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #ludo-board {
            width: var(--board-size);
            height: var(--board-size);
            background-color: white;
            border: 5px solid #333;
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            position: relative;
        }
        
        .base {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            place-items: center;
            padding: calc(var(--cell-size) / 2);
            border-radius: 8px;
        }

        #red-base { grid-area: 1 / 1 / span 6 / span 6; background-color: var(--red); }
        #green-base { grid-area: 1 / 10 / span 6 / span 6; background-color: var(--green); }
        #yellow-base { grid-area: 10 / 10 / span 6 / span 6; background-color: var(--yellow); }
        #blue-base { grid-area: 10 / 1 / span 6 / span 6; background-color: var(--blue); }

        .home-area {
            background-color: white;
            border-radius: 50%;
            width: 80%;
            height: 80%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            place-items: center;
            padding: 5%;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        .token-yard {
            width: var(--token-size);
            height: var(--token-size);
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 50%;
        }
        
        .path { border: 1px solid var(--light-gray); }
        .safe { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23cccccc' d='M12 2l2.5 8h8.5l-7 5.5 2.5 8-7-5.5-7 5.5 2.5-8-7-5.5h8.5z'/%3E%3C/svg%3E"); background-size: 60%; background-position: center; background-repeat: no-repeat; }

        /* Color Paths */
        .red-path { background-color: var(--red); }
        .green-path { background-color: var(--green); }
        .yellow-path { background-color: var(--yellow); }
        .blue-path { background-color: var(--blue); }

        /* Home Triangle */
        #home-triangle {
            grid-area: 7 / 7 / span 3 / span 3;
            position: relative;
        }
        #home-triangle::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: calc(var(--board-size) / 10) solid transparent;
            border-right: calc(var(--board-size) / 10) solid transparent;
            border-bottom: calc(var(--board-size) / 10) solid var(--red);
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        #home-triangle::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: calc(var(--board-size) / 10) solid transparent;
            border-right: calc(var(--board-size) / 10) solid transparent;
            border-top: calc(var(--board-size) / 10) solid var(--yellow);
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        #home-triangle > div:nth-child(1) {
            position: absolute;
            width: 0;
            height: 0;
            border-top: calc(var(--board-size) / 10) solid transparent;
            border-bottom: calc(var(--board-size) / 10) solid transparent;
            border-right: calc(var(--board-size) / 10) solid var(--green);
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        #home-triangle > div:nth-child(2) {
            position: absolute;
            width: 0;
            height: 0;
            border-top: calc(var(--board-size) / 10) solid transparent;
            border-bottom: calc(var(--board-size) / 10) solid transparent;
            border-left: calc(var(--board-size) / 10) solid var(--blue);
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .token {
            position: absolute;
            width: var(--token-size);
            height: var(--token-size);
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 2px black;
            z-index: 10;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
        }

        .red-token { background-color: var(--red); }
        .green-token { background-color: var(--green); }
        .yellow-token { background-color: var(--yellow); }
        .blue-token { background-color: var(--blue); }

        .token.movable {
            animation: pulse 1s infinite;
            box-shadow: 0 0 15px 5px white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            background-color: #444;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        #dice {
            width: 60px;
            height: 60px;
            background-color: white;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            font-weight: bold;
            color: var(--dark-gray);
            cursor: pointer;
            transition: transform 0.2s;
            border: 3px solid var(--light-gray);
        }
        #dice:hover {
            transform: scale(1.05);
        }
        #dice.rolling {
            animation: roll 0.5s ease-out;
        }
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(360deg) scale(1.2); }
        }

        #game-status {
            color: white;
            font-size: 1.2em;
            min-width: 250px;
            text-align: center;
        }
        
        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .winner-box {
            background-color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        .winner-box h2 {
            font-size: 3em;
            margin: 0 0 20px 0;
            text-transform: capitalize;
        }
        #restart-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="ludo-board"></div>
        <div class="controls">
            <div id="dice">🎲</div>
            <div id="game-status">Red's turn</div>
        </div>
    </div>

    <div id="winner-overlay" class="winner-overlay">
        <div class="winner-box">
            <h2 id="winner-message"></h2>
            <button id="restart-btn">Play Again</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const board = document.getElementById('ludo-board');
            const dice = document.getElementById('dice');
            const status = document.getElementById('game-status');
            const winnerOverlay = document.getElementById('winner-overlay');
            const winnerMessage = document.getElementById('winner-message');
            const restartBtn = document.getElementById('restart-btn');

            const players = ['red', 'green', 'yellow', 'blue'];
            const colors = { red: '#ff4d4d', green: '#4caf50', yellow: '#ffeb3b', blue: '#2196f3' };
            const startPositions = { red: 1, green: 14, yellow: 27, blue: 40 };
            const homeEntrances = { red: 52, green: 52, yellow: 64, blue: 70 };
            const homePaths = {
                red: [52, 53, 54, 55, 56, 57],
                green: [58, 59, 60, 61, 62, 63],
                yellow: [64, 65, 66, 67, 68, 69],
                blue: [70, 71, 72, 73, 74, 75]
            };

            let currentPlayerIndex = 0;
            let diceValue = 0;
            let diceRolled = false;
            let tokens = {};

            // Path coordinates for placing cells
            const pathCoords = [
                // Red Path
                {r:7,c:2}, {r:7,c:3}, {r:7,c:4}, {r:7,c:5}, {r:7,c:6},
                {r:6,c:7}, {r:5,c:7}, {r:4,c:7}, {r:3,c:7}, {r:2,c:7},
                {r:1,c:7}, {r:1,c:8}, {r:1,c:9},
                // Green Path
                {r:2,c:9}, {r:3,c:9}, {r:4,c:9}, {r:5,c:9}, {r:6,c:9},
                {r:7,c:10}, {r:7,c:11}, {r:7,c:12}, {r:7,c:13}, {r:7,c:14},
                {r:7,c:15}, {r:8,c:15}, {r:9,c:15},
                // Blue Path
                {r:9,c:14}, {r:9,c:13}, {r:9,c:12}, {r:9,c:11}, {r:9,c:10},
                {r:10,c:9}, {r:11,c:9}, {r:12,c:9}, {r:13,c:9}, {r:14,c:9},
                {r:15,c:9}, {r:15,c:8}, {r:15,c:7},
                // Yellow Path
                {r:14,c:7}, {r:13,c:7}, {r:12,c:7}, {r:11,c:7}, {r:10,c:7},
                {r:9,c:6}, {r:9,c:5}, {r:9,c:4}, {r:9,c:3}, {r:9,c:2},
                {r:9,c:1}, {r:8,c:1}, {r:7,c:1}
            ];

            const homePathCoords = {
                red: [{r:8,c:2}, {r:8,c:3}, {r:8,c:4}, {r:8,c:5}, {r:8,c:6}, {r:8,c:7}],
                green: [{r:2,c:8}, {r:3,c:8}, {r:4,c:8}, {r:5,c:8}, {r:6,c:8}, {r:7,c:8}],
                yellow: [{r:8,c:14}, {r:8,c:13}, {r:8,c:12}, {r:8,c:11}, {r:8,c:10}, {r:8,c:9}],
                blue: [{r:14,c:8}, {r:13,c:8}, {r:12,c:8}, {r:11,c:8}, {r:10,c:8}, {r:9,c:8}]
            };

            const safeSpots = [1, 9, 14, 22, 27, 35, 40, 48];

            function createBoard() {
                // Bases
                board.innerHTML = `
                    <div id="red-base" class="base"><div class="home-area"></div></div>
                    <div id="green-base" class="base"><div class="home-area"></div></div>
                    <div id="yellow-base" class="base"><div class="home-area"></div></div>
                    <div id="blue-base" class="base"><div class="home-area"></div></div>
                    <div id="home-triangle"><div></div><div></div></div>
                `;

                // Main path
                pathCoords.forEach((coord, i) => {
                    const cell = document.createElement('div');
                    cell.classList.add('cell', 'path');
                    cell.style.gridRow = coord.r;
                    cell.style.gridColumn = coord.c;
                    cell.dataset.pathIndex = i + 1;
                    if (safeSpots.includes(i + 1)) {
                        cell.classList.add('safe');
                    }
                    if (i + 1 === startPositions.red) cell.style.backgroundColor = 'rgba(255, 77, 77, 0.3)';
                    if (i + 1 === startPositions.green) cell.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                    if (i + 1 === startPositions.yellow) cell.style.backgroundColor = 'rgba(255, 235, 59, 0.3)';
                    if (i + 1 === startPositions.blue) cell.style.backgroundColor = 'rgba(33, 150, 243, 0.3)';
                    board.appendChild(cell);
                });

                // Home paths
                Object.keys(homePathCoords).forEach(color => {
                    homePathCoords[color].forEach((coord, i) => {
                        const cell = document.createElement('div');
                        cell.classList.add('cell', `${color}-path`);
                        cell.style.gridRow = coord.r;
                        cell.style.gridColumn = coord.c;
                        cell.dataset.homePathIndex = homePaths[color][i];
                        board.appendChild(cell);
                    });
                });
            }

            function createTokens() {
                tokens = {};
                players.forEach(player => {
                    tokens[player] = [];
                    const base = document.querySelector(`#${player}-base .home-area`);
                    base.innerHTML = ''; // Clear previous tokens
                    for (let i = 0; i < 4; i++) {
                        const tokenEl = document.createElement('div');
                        tokenEl.classList.add('token', `${player}-token`);
                        tokenEl.id = `${player}-token-${i}`;
                        
                        const tokenObj = {
                            id: i,
                            color: player,
                            position: -1, // -1 means in base
                            element: tokenEl,
                            isHome: false
                        };
                        tokens[player].push(tokenObj);

                        const yardSpot = document.createElement('div');
                        yardSpot.classList.add('token-yard');
                        yardSpot.appendChild(tokenEl);
                        base.appendChild(yardSpot);
                        
                        tokenEl.addEventListener('click', () => onTokenClick(tokenObj));
                    }
                });
            }

            function rollDice() {
                if (diceRolled) return;
                dice.classList.add('rolling');
                
                setTimeout(() => {
                    diceValue = Math.floor(Math.random() * 6) + 1;
                    dice.textContent = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'][diceValue - 1];
                    dice.classList.remove('rolling');
                    diceRolled = true;
                    status.textContent = `${players[currentPlayerIndex]} rolled a ${diceValue}`;
                    checkMovableTokens();
                }, 500);
            }

            function checkMovableTokens() {
                const currentPlayer = players[currentPlayerIndex];
                const playerTokens = tokens[currentPlayer];
                let hasMovableToken = false;

                playerTokens.forEach(token => {
                    if (isMovable(token)) {
                        token.element.classList.add('movable');
                        hasMovableToken = true;
                    }
                });

                if (!hasMovableToken) {
                    setTimeout(nextTurn, 1000);
                }
            }
            
            function isMovable(token) {
                if (token.isHome) return false;

                if (token.position === -1) { // In base
                    return diceValue === 6;
                }
                
                // Check if move is within home path
                const homePathIndex = homePaths[token.color].indexOf(token.position);
                if (homePathIndex !== -1) {
                    return homePathIndex + diceValue < homePaths[token.color].length;
                }

                return true;
            }

            function onTokenClick(token) {
                if (token.color !== players[currentPlayerIndex] || !diceRolled || !token.element.classList.contains('movable')) {
                    return;
                }
                
                moveToken(token);
            }

            function moveToken(token) {
                // Clear movable highlights
                document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));

                if (token.position === -1 && diceValue === 6) {
                    token.position = startPositions[token.color];
                } else {
                    const homeEntrance = homeEntrances[token.color];
                    const currentPathIndex = pathCoords.findIndex(p => p.r === token.element.parentElement.style.gridRow.slice(0,-2) && p.c === token.element.parentElement.style.gridColumn.slice(0,-2)) + 1;
                    
                    const stepsToHomeEntrance = (homeEntrance >= token.position) 
                        ? homeEntrance - token.position 
                        : (52 - token.position) + homeEntrance;

                    if (token.position > 51) { // Already in home path
                        const homePathIdx = homePaths[token.color].indexOf(token.position);
                        token.position = homePaths[token.color][homePathIdx + diceValue];
                    } else if (diceValue > stepsToHomeEntrance + 1) { // Moving into home path
                        const stepsIntoHome = diceValue - (stepsToHomeEntrance + 1);
                        token.position = homePaths[token.color][stepsIntoHome];
                    } else { // Moving on main path
                        token.position = (token.position + diceValue - 1) % 52 + 1;
                    }
                }
                
                if (token.position === homePaths[token.color][5]) { // Reached home
                    token.isHome = true;
                }

                updateBoard();
                checkCapture(token);
                
                if (diceValue === 6 || token.isHome) {
                    resetTurn();
                } else {
                    nextTurn();
                }
                checkWin();
            }
            
            function updateBoard() {
                players.forEach(player => {
                    tokens[player].forEach(token => {
                        let targetCell;
                        if (token.position === -1) {
                             targetCell = document.querySelector(`#${player}-token-${token.id}`).parentElement;
                        } else if (token.position > 51) { // Home path
                            if (token.isHome) {
                                targetCell = document.querySelector(`#home-triangle`);
                            } else {
                                targetCell = document.querySelector(`[data-home-path-index='${token.position}']`);
                            }
                        } else { // Main path
                            targetCell = document.querySelector(`[data-path-index='${token.position}']`);
                        }
                        if (targetCell) {
                           // Handle multiple tokens on one cell
                            const existingTokens = targetCell.querySelectorAll('.token');
                            if (existingTokens.length > 0 && !safeSpots.includes(token.position)) {
                                let offset = existingTokens.length * 5;
                                token.element.style.transform = `translate(${offset}px, ${offset}px)`;
                            } else {
                                token.element.style.transform = 'translate(0,0)';
                            }
                            targetCell.appendChild(token.element);
                        }
                    });
                });
            }

            function checkCapture(movedToken) {
                if (movedToken.position > 51 || safeSpots.includes(movedToken.position)) return;

                const targetCell = movedToken.element.parentElement;
                const tokensInCell = Array.from(targetCell.querySelectorAll('.token'));

                tokensInCell.forEach(tEl => {
                    const t = findTokenByElement(tEl);
                    if (t && t.color !== movedToken.color) {
                        t.position = -1; // Send back to base
                    }
                });
                updateBoard();
            }
            
            function findTokenByElement(el) {
                for (const player of players) {
                    for (const token of tokens[player]) {
                        if (token.element === el) {
                            return token;
                        }
                    }
                }
                return null;
            }

            function nextTurn() {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                resetTurn();
            }

            function resetTurn() {
                diceRolled = false;
                diceValue = 0;
                dice.textContent = '🎲';
                const currentPlayer = players[currentPlayerIndex];
                status.textContent = `${currentPlayer}'s turn`;
                status.style.color = colors[currentPlayer];
                dice.style.borderColor = colors[currentPlayer];
            }

            function checkWin() {
                const currentPlayer = players[currentPlayerIndex];
                const playerTokens = tokens[currentPlayer];
                if (playerTokens.every(t => t.isHome)) {
                    winnerMessage.textContent = `${currentPlayer} wins!`;
                    winnerMessage.style.color = colors[currentPlayer];
                    restartBtn.style.backgroundColor = colors[currentPlayer];
                    winnerOverlay.style.display = 'flex';
                }
            }
            
            function initGame() {
                board.innerHTML = '';
                winnerOverlay.style.display = 'none';
                createBoard();
                createTokens();
                currentPlayerIndex = 0;
                resetTurn();
                updateBoard();
            }

            dice.addEventListener('click', rollDice);
            restartBtn.addEventListener('click', initGame);

            initGame();
        });
    </script>
</body>
</html>
